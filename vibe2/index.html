<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Escape</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-panel">
            <div id="distance-display">Dist: 0</div>
        </div>
    </div>

    <div id="message-overlay" class="visible">
        <h1 id="msg-title">Space Escape</h1>
        <p id="msg-body"><!--to be replaced--></p>
        <button id="start-btn">Start</button>
        <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="seed-btn"
                style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); margin: 0; flex: 1; height: 46px; display: flex; align-items: center; justify-content: center;">Level</button>
            <button id="random-seed-btn" title="Random Level"
                style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); margin: 0; width: 50px; height: 46px; display: flex; align-items: center; justify-content: center; padding: 0;">ðŸŽ²</button>
        </div>
        <button id="fs-btn"
            style="margin-left: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3);">Full
            Screen</button>
    </div>

    <!-- Mobile Controls -->
    <div id="controls">
        <div class="control-group">
            <div id="joystickContainer">
                <div id="joystickKnob"></div>
            </div>
        </div>
        <div class="control-group">
            <div class="control-btn" id="btnThrust">â†‘</div>
        </div>
    </div>

    <script>
        // --- Constants & Config ---
        const GRAVITY = 0.05;
        const THRUST_POWER = 0.15;
        const ROTATION_SPEED = 0.05;
        const DRAG = 0.995; // Air resistance
        const SAFE_LANDING_SPEED = 1.5;
        const SAFE_LANDING_ANGLE = 0.2; // Radians deviation from vertical
        const PARTICLE_LIFETIME = 60;

        const GAME_STATUS = {
            START: 'start',
            PLAYING: 'playing',
            CRASHED: 'crashed',
            WIN: 'win'
        };

        // --- Game State ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let animationId;
        let lastTime = 0;

        const keys = {
            ArrowUp: false,
            ArrowLeft: false,
            ArrowRight: false,
            KeyW: false,
            KeyA: false,
            KeyD: false
        };

        const gameState = {
            status: GAME_STATUS.START,
            camera: { x: 0, y: 0, zoom: 1 },
            particles: [],
            mines: []
        };

        const ship = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            angle: -Math.PI / 2, // Pointing up
            radius: 10,
            color: 'black',
            landed: true
        };

        // --- Terrain Generation ---
        class TerrainNode {
            constructor() {
                this.segments = [];
                this.prev = null;
                this.next = null;
                this.minX = Infinity;
                this.maxX = -Infinity;
                // Points to continue generation from either side
                this.leftFloor = null;
                this.leftCeiling = null;
                this.rightFloor = null;
                this.rightCeiling = null;
            }
        }

        const terrain = {
            head: null,
            tail: null,
            grid2D: {},
            cellSize: 300,
            fFinishLine: null,
            bFinishLine: null,
            targetDistance: 5000,
            // Generation state
            fIteration: 0,
            bIteration: 0,
            fLastFloor: null,
            fLastCeiling: null,
            bLastFloor: null,
            bLastCeiling: null,
            tunnelWidth: 400,
            fFinishGenerated: false,
            bFinishGenerated: false,
            sineOffset: 0
        };

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Input Handling ---
        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.code)) keys[e.code] = true;
            if (e.code === 'Enter') {
                if (gameState.status !== GAME_STATUS.PLAYING) {
                    resetGame();
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.code)) keys[e.code] = false;
        });

        document.getElementById('start-btn').addEventListener('click', () => {
            if (gameState.status !== GAME_STATUS.PLAYING) {
                resetGame();
            }
        });

        // Set initial controls message based on device type
        const updateControlsText = () => {
            const isTouch = window.matchMedia('(pointer: coarse)').matches;
            const msgBody = document.getElementById('msg-body');
            if (msgBody && gameState.status === GAME_STATUS.START) {
                msgBody.innerText = isTouch ? 'Controls: Joystick & Thrust button' : 'Controls: â†â†‘â†’ or WAD';
            }
        };
        updateControlsText();
        window.matchMedia('(pointer: coarse)').addEventListener('change', updateControlsText);

        document.getElementById('fs-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else {
                document.exitFullscreen();
            }
        });

        const applySeed = (newSeed) => {
            const url = new URL(window.location.href);
            url.searchParams.set('seed', newSeed);
            window.history.pushState({}, '', url);
            generateLevel();
            // Reset ship for preview
            ship.x = 0;
            ship.y = 89;
            ship.vx = 0;
            ship.vy = 0;
            ship.angle = -Math.PI / 2;
            ship.landed = true;
            if (gameState.status !== GAME_STATUS.PLAYING) {
                gameState.status = GAME_STATUS.START;
            }
        };

        document.getElementById('seed-btn').addEventListener('click', () => {
            const currentSeed = getUrlParams().seed;
            const newSeed = prompt('Enter a level seed (number):', currentSeed);
            if (newSeed !== null && newSeed !== '') {
                applySeed(newSeed);
            }
        });

        document.getElementById('random-seed-btn').addEventListener('click', () => {
            applySeed(Math.floor(Math.random() * 10000));
        });

        // --- Mobile Controls Logic ---
        let joystickActive = false;
        let joystickHasMoved = false;
        let joystickAngle = 0;
        let joystickCenter = { x: 0, y: 0 };
        let joystickTouchId = null;
        const maxRadius = 35;

        const btnThrust = document.getElementById('btnThrust');
        const joystickContainer = document.getElementById('joystickContainer');
        const joystickKnob = document.getElementById('joystickKnob');

        function setupTouchControl(elem, code, onStart) {
            let activeTouches = new Set();

            const handleStart = (e) => {
                e.preventDefault();
                if (e.changedTouches) {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        activeTouches.add(e.changedTouches[i].identifier);
                    }
                }

                if (onStart) {
                    if (onStart()) return;
                }
                keys[code] = true;
                elem.classList.add('active');
            };

            const handleEnd = (e) => {
                e.preventDefault();
                if (e.changedTouches) {
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        activeTouches.delete(e.changedTouches[i].identifier);
                    }
                }

                if (activeTouches.size === 0) {
                    keys[code] = false;
                    elem.classList.remove('active');
                }
            };

            elem.addEventListener('touchstart', handleStart, { passive: false });
            elem.addEventListener('touchend', handleEnd, { passive: false });
            elem.addEventListener('touchcancel', handleEnd, { passive: false });
            elem.addEventListener('mousedown', handleStart);
            elem.addEventListener('mouseup', handleEnd);
            elem.addEventListener('mouseleave', handleEnd);
        }

        if (btnThrust) {
            setupTouchControl(btnThrust, 'ArrowUp', () => {
                if (gameState.status !== GAME_STATUS.PLAYING) {
                    resetGame();
                    return true;
                }
                return false;
            });
        }

        function handleJoystickStart(e) {
            e.preventDefault();

            let touch;
            if (e.changedTouches) {
                touch = e.changedTouches[0];
                joystickTouchId = touch.identifier;
            } else {
                touch = e;
            }

            joystickActive = true;
            joystickHasMoved = false;

            joystickCenter = {
                x: touch.clientX,
                y: touch.clientY
            };
            // Don't call move yet to establish neutral start
        }

        function handleJoystickMove(e) {
            if (!joystickActive) return;
            e.preventDefault();

            let touch = null;
            if (e.touches) {
                for (let i = 0; i < e.touches.length; i++) {
                    if (e.touches[i].identifier === joystickTouchId) {
                        touch = e.touches[i];
                        break;
                    }
                }
            } else {
                touch = e;
            }

            if (!touch) return;

            let deltaX = touch.clientX - joystickCenter.x;
            let deltaY = touch.clientY - joystickCenter.y;

            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            // Visual update
            let visualDeltaX = deltaX;
            let visualDeltaY = deltaY;

            if (distance > maxRadius) {
                const ratio = maxRadius / distance;
                visualDeltaX *= ratio;
                visualDeltaY *= ratio;
            }

            joystickKnob.style.transform = `translate(calc(-50% + ${visualDeltaX}px), calc(-50% + ${visualDeltaY}px))`;

            joystickHasMoved = true;
            joystickAngle = Math.atan2(deltaY, deltaX);
        }

        function handleJoystickEnd(e) {
            if (e.changedTouches) {
                let found = false;
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === joystickTouchId) {
                        found = true;
                        break;
                    }
                }
                if (!found) return;
            }

            e.preventDefault();
            joystickActive = false;
            joystickTouchId = null;
            joystickHasMoved = false;
            joystickKnob.style.transform = `translate(-50%, -50%)`;
        }

        if (joystickContainer) {
            joystickContainer.addEventListener('touchstart', handleJoystickStart, { passive: false });
            joystickContainer.addEventListener('touchmove', handleJoystickMove, { passive: false });
            joystickContainer.addEventListener('touchend', handleJoystickEnd, { passive: false });
            joystickContainer.addEventListener('mousedown', handleJoystickStart);
            window.addEventListener('mousemove', handleJoystickMove);
            window.addEventListener('mouseup', handleJoystickEnd);
        }

        // --- Core Logic ---

        // Better Seeded RNG (Mulberry32 style)
        let seed = 12345;
        function seededRandom() {
            let t = seed += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }

        function getUrlParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                length: parseInt(params.get('length') ?? 1000),
                seed: parseInt(params.get('seed') ?? Math.floor(Math.random() * 100)),
                mines: parseInt(params.get('mines') ?? 3),
                zoom: parseFloat(params.get('zoom') ?? 1.0)
            };
        }

        function addSegmentToGrid(seg) {
            const minX = Math.min(seg.p1.x, seg.p2.x);
            const maxX = Math.max(seg.p1.x, seg.p2.x);
            const minY = Math.min(seg.p1.y, seg.p2.y);
            const maxY = Math.max(seg.p1.y, seg.p2.y);

            const startX = Math.floor(minX / terrain.cellSize);
            const endX = Math.floor(maxX / terrain.cellSize);
            const startY = Math.floor(minY / terrain.cellSize);
            const endY = Math.floor(maxY / terrain.cellSize);

            for (let x = startX; x <= endX; x++) {
                for (let y = startY; y <= endY; y++) {
                    const key = `${x},${y}`;
                    if (!terrain.grid2D[key]) terrain.grid2D[key] = [];
                    terrain.grid2D[key].push(seg);
                }
            }
        }

        function removeSegmentFromGrid(seg) {
            const minX = Math.min(seg.p1.x, seg.p2.x);
            const maxX = Math.max(seg.p1.x, seg.p2.x);
            const minY = Math.min(seg.p1.y, seg.p2.y);
            const maxY = Math.max(seg.p1.y, seg.p2.y);

            const startX = Math.floor(minX / terrain.cellSize);
            const endX = Math.floor(maxX / terrain.cellSize);
            const startY = Math.floor(minY / terrain.cellSize);
            const endY = Math.floor(maxY / terrain.cellSize);

            for (let x = startX; x <= endX; x++) {
                for (let y = startY; y <= endY; y++) {
                    const key = `${x},${y}`;
                    const bucket = terrain.grid2D[key];
                    if (bucket) {
                        const idx = bucket.indexOf(seg);
                        if (idx !== -1) bucket.splice(idx, 1);
                        if (bucket.length === 0) delete terrain.grid2D[key];
                    }
                }
            }
        }

        function generateTerrainNode(direction) {
            const node = new TerrainNode();
            const segmentsPerNode = 10;
            const isForward = direction === 'forward';

            // Initialize boundaries to current generation head/tail
            const startX = isForward ? terrain.fLastFloor.x : terrain.bLastFloor.x;
            node.minX = startX;
            node.maxX = startX;

            const addSeg = (seg) => {
                node.segments.push(seg);
                addSegmentToGrid(seg);
                node.minX = Math.min(node.minX, seg.p1.x, seg.p2.x);
                node.maxX = Math.max(node.maxX, seg.p1.x, seg.p2.x);
            };

            // Store starting points
            if (isForward) {
                node.leftFloor = { ...terrain.fLastFloor };
                node.leftCeiling = { ...terrain.fLastCeiling };
            } else {
                node.rightFloor = { ...terrain.bLastFloor };
                node.rightCeiling = { ...terrain.bLastCeiling };
            }

            for (let k = 0; k < segmentsPerNode; k++) {
                const i = isForward ? terrain.fIteration++ : terrain.bIteration++;
                const lastFloor = isForward ? terrain.fLastFloor : terrain.bLastFloor;
                const lastCeiling = isForward ? terrain.fLastCeiling : terrain.bLastCeiling;

                const currentDist = isForward ? lastFloor.x : -lastFloor.x;

                if (currentDist >= terrain.targetDistance) {
                    if (isForward && !terrain.fFinishGenerated) {
                        terrain.fFinishGenerated = true;
                        terrain.fFinishLine = { p1: { ...lastFloor }, p2: { ...lastCeiling } };
                    } else if (!isForward && !terrain.bFinishGenerated) {
                        terrain.bFinishGenerated = true;
                        terrain.bFinishLine = { p1: { ...lastFloor }, p2: { ...lastCeiling } };
                    }
                    break;
                }

                const len = 40 + seededRandom() * 140;
                const sectionIndex = Math.floor(i / 20);
                const mode = Math.floor(seededRandom() * 4);
                let angle;

                if (mode === 0) {
                    // Mode 0: Flowing Sine (Classic)
                    const si = i + terrain.sineOffset;
                    angle = (Math.sin(si * 0.07) * 0.5) + (Math.sin(si * 0.17) * 0.4) + (seededRandom() - 0.5) * 0.5;
                } else if (mode === 1) {
                    // Mode 1: Steady Drift (Picks an angle and maintains it with some noise)
                    // Use a simple hash of section index for consistent drift within the section
                    const drift = ((Math.sin(sectionIndex * 1.57) * 1000) % 1) * 2 - 1; // -1 to 1
                    angle = drift * 1.1 + (seededRandom() - 0.5) * 0.4;
                } else if (mode === 2) {
                    // Mode 2: Jagged Chaos (No trend, pure aggressive noise)
                    angle = (seededRandom() - 0.5) * 2.8;
                } else {
                    // Mode 3: Tight Corridors (Near horizontal, low noise)
                    angle = (seededRandom() - 0.5) * 0.3;
                }

                // Global clamp to keep it mostly forward-ish but allow very steep sections
                angle = Math.max(-1.48, Math.min(1.48, angle));
                if (!isForward) angle = Math.PI - angle;

                const nx = lastFloor.x + Math.cos(angle) * len;
                const ny = lastFloor.y + Math.sin(angle) * len;
                const currentWidth = terrain.tunnelWidth * (0.8 + seededRandom() * 0.4);

                let floorP = { x: nx, y: ny };
                let ceilingP = {
                    x: nx + (seededRandom() - 0.5) * 30,
                    y: ny - currentWidth + (seededRandom() - 0.5) * 30
                };

                addSeg({ p1: { ...lastFloor }, p2: { ...floorP }, color: '#06b6d4', type: 'floor' });
                addSeg({ p1: { ...lastCeiling }, p2: { ...ceilingP }, color: '#f472b6', type: 'ceiling' });

                if (isForward) {
                    terrain.fLastFloor = floorP;
                    terrain.fLastCeiling = ceilingP;
                } else {
                    terrain.bLastFloor = floorP;
                    terrain.bLastCeiling = ceilingP;
                }
            }

            if (isForward) {
                node.prev = terrain.tail;
                if (terrain.tail) terrain.tail.next = node;
                terrain.tail = node;
                if (!terrain.head) terrain.head = node;
                node.rightFloor = { ...terrain.fLastFloor };
                node.rightCeiling = { ...terrain.fLastCeiling };
            } else {
                node.next = terrain.head;
                if (terrain.head) terrain.head.prev = node;
                terrain.head = node;
                if (!terrain.tail) terrain.tail = node;
                node.leftFloor = { ...terrain.bLastFloor };
                node.leftCeiling = { ...terrain.bLastCeiling };
            }

            return node;
        }

        function updateDynamicTerrain() {
            const forwardThreshold = 2000;
            const backwardThreshold = 2000;

            // Add nodes forward
            while (!terrain.tail || (ship.x > terrain.tail.maxX - forwardThreshold)) {
                if (terrain.tail && terrain.tail.maxX >= terrain.targetDistance) break;
                generateTerrainNode('forward');
            }

            // Add nodes backward
            while (!terrain.head || (ship.x < terrain.head.minX + backwardThreshold)) {
                if (terrain.head && terrain.head.minX <= -terrain.targetDistance) break;
                generateTerrainNode('backward');
            }

            // Cull far nodes
            const cullSize = 4000;
            while (terrain.head && terrain.head.next && (ship.x > terrain.head.maxX + cullSize)) {
                const oldNode = terrain.head;
                terrain.head = oldNode.next;
                terrain.head.prev = null;
                oldNode.segments.forEach(removeSegmentFromGrid);
                // Sync backward generator anchor to new head's left side
                terrain.bLastFloor = { ...terrain.head.leftFloor };
                terrain.bLastCeiling = { ...terrain.head.leftCeiling };
            }
            while (terrain.tail && terrain.tail.prev && (ship.x < terrain.tail.minX - cullSize)) {
                const oldNode = terrain.tail;
                terrain.tail = oldNode.prev;
                terrain.tail.next = null;
                oldNode.segments.forEach(removeSegmentFromGrid);
                // Sync forward generator anchor to new tail's right side
                terrain.fLastFloor = { ...terrain.tail.rightFloor };
                terrain.fLastCeiling = { ...terrain.tail.rightCeiling };
            }
        }

        function updateDynamicMines() {
            const params = getUrlParams();
            const targetCount = params.mines;

            // 1. Cull far mines
            const cullDistance = 2500;
            for (let i = gameState.mines.length - 1; i >= 0; i--) {
                const dist = Math.abs(gameState.mines[i].x - ship.x);
                if (dist > cullDistance) {
                    gameState.mines.splice(i, 1);
                }
            }

            // 2. Spawn new mines if below target
            if (gameState.mines.length < targetCount) {
                const spawnRange = 2000;
                for (let attempts = 0; attempts < 5; attempts++) {
                    if (gameState.mines.length >= targetCount) break;

                    const rx = ship.x + (seededRandom() - 0.5) * spawnRange * 2;
                    if (Math.abs(rx - ship.x) < 300) continue;

                    const { floorY, ceilingY } = getTerrainAt(rx, 0);
                    if (floorY !== null && ceilingY !== null) {
                        const minY = Math.min(floorY, ceilingY);
                        const maxY = Math.max(floorY, ceilingY);
                        const height = maxY - minY;

                        if (height > 100) {
                            gameState.mines.push({
                                x: rx,
                                y: minY + height * (0.2 + seededRandom() * 0.6),
                                vx: 0,
                                vy: 0,
                                radius: 12,
                                state: 'idle',
                                active: true,
                                type: seededRandom() > 0.3 ? 'seeker' : 'gravity'
                            });
                        }
                    }
                }
            }
        }

        function generateLevel() {
            const params = getUrlParams();
            seed = params.seed;
            gameState.camera.zoom = params.zoom;
            terrain.targetDistance = params.length * (25 / 3); // Convert meters to pixels (25px = 3m)

            // Update Level button text
            const seedBtn = document.getElementById('seed-btn');
            if (seedBtn) seedBtn.innerText = `Seed: ${seed}`;

            // Ensure params are in URL
            const url = new URL(window.location.href);
            let updated = false;
            if (!url.searchParams.has('seed')) {
                url.searchParams.set('seed', seed);
                updated = true;
            }
            if (updated) {
                window.history.replaceState({}, '', url);
            }

            // Reset terrain state
            terrain.head = null;
            terrain.tail = null;
            terrain.grid2D = {};
            terrain.fIteration = 0;
            terrain.bIteration = 0;
            terrain.tunnelWidth = 400;
            terrain.fFinishLine = null;
            terrain.bFinishLine = null;
            terrain.fFinishGenerated = false;
            terrain.bFinishGenerated = false;
            terrain.sineOffset = seededRandom() * 1000;

            // Start Pad
            const startNode = new TerrainNode();
            const padHalfLen = 150;
            const floorY = 100;
            const ceilY = floorY - terrain.tunnelWidth;

            const padSeg = { p1: { x: -padHalfLen, y: floorY }, p2: { x: padHalfLen, y: floorY }, color: '#22c55e', type: 'floor' };
            const ceilSeg = { p1: { x: -padHalfLen, y: ceilY }, p2: { x: padHalfLen, y: ceilY }, color: '#f472b6', type: 'ceiling' };

            startNode.segments.push(padSeg, ceilSeg);
            startNode.minX = -padHalfLen;
            startNode.maxX = padHalfLen;
            startNode.leftFloor = { x: -padHalfLen, y: floorY };
            startNode.leftCeiling = { x: -padHalfLen, y: ceilY };
            startNode.rightFloor = { x: padHalfLen, y: floorY };
            startNode.rightCeiling = { x: padHalfLen, y: ceilY };

            terrain.head = startNode;
            terrain.tail = startNode;
            startNode.segments.forEach(addSegmentToGrid);

            terrain.fLastFloor = { x: padHalfLen, y: floorY };
            terrain.fLastCeiling = { x: padHalfLen, y: ceilY };
            terrain.bLastFloor = { x: -padHalfLen, y: floorY };
            terrain.bLastCeiling = { x: -padHalfLen, y: ceilY };

            gameState.mines = [];

            // Initial nodes in both directions
            for (let i = 0; i < 3; i++) {
                generateTerrainNode('forward');
                generateTerrainNode('backward');
            }
        }

        function resetGame() {
            generateLevel();

            // Spawn ship at start pad
            ship.x = 0;
            ship.y = 89; // Landed position (100 - 11)
            ship.vx = 0;
            ship.vy = 0;
            ship.angle = -Math.PI / 2;
            ship.landed = true;

            gameState.status = GAME_STATUS.PLAYING;
            gameState.particles = [];

            document.getElementById('message-overlay').classList.remove('visible');

            if (!animationId) {
                lastTime = performance.now();
                animationId = requestAnimationFrame(loop);
            }
        }

        function createExplosion(x, y) {
            for (let i = 0; i < 60; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 1.0 + Math.random() * 0.5,
                    decay: 0.02,
                    size: 3,
                    color: `hsl(${Math.random() * 60}, 100%, 50%)`, // Fire colors
                    type: 'explosion'
                });
            }
        }

        function createThrustParticles() {
            // Emit from tip of the flame
            // Flame length is roughly 15-20px behind the ship center
            const flameLen = 25;
            const tipX = ship.x - Math.cos(ship.angle) * flameLen;
            const tipY = ship.y - Math.sin(ship.angle) * flameLen;

            // Smoke - Generate more particles
            for (let i = 0; i < 2; i++) {
                gameState.particles.push({
                    x: tipX + (Math.random() - 0.5) * 5, // Slight spread at source
                    y: tipY + (Math.random() - 0.5) * 5,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    life: 1.0,
                    decay: 0.01 + Math.random() * 0.02, // Vary decay slightly
                    size: 1 + Math.random() * 2, // Smaller start size
                    color: `rgba(150, 150, 150, 0.4)`,
                    type: 'smoke'
                });
            }
        }

        function updatePhysics(dt) {
            updateDynamicTerrain();
            updateDynamicMines();

            // Controls
            const thrusting = keys.ArrowUp || keys.KeyW;

            if (thrusting) {
                ship.landed = false;
            }

            if (ship.landed) return;

            if (joystickActive && joystickHasMoved) {
                // Immediate rotation to joystick angle
                ship.angle = joystickAngle;
            } else {
                const rotatingLeft = keys.ArrowLeft || keys.KeyA;
                const rotatingRight = keys.ArrowRight || keys.KeyD;
                if (rotatingLeft) ship.angle -= ROTATION_SPEED * dt;
                if (rotatingRight) ship.angle += ROTATION_SPEED * dt;
            }

            if (thrusting) {
                ship.vx += Math.cos(ship.angle) * THRUST_POWER * dt;
                ship.vy += Math.sin(ship.angle) * THRUST_POWER * dt;
                createThrustParticles();
            }

            // Gravity
            ship.vy += GRAVITY * dt;

            // Drag
            ship.vx *= Math.pow(DRAG, dt);
            ship.vy *= Math.pow(DRAG, dt);

            // Apply velocity
            ship.x += ship.vx * dt;
            ship.y += ship.vy * dt;

            // Collision Detection
            checkCollisions();

            // Win condition: Cross the finish line
            const checkFinish = (finish) => {
                return finish && checkLineIntersection(
                    { x: ship.x, y: ship.y },
                    { x: ship.x + ship.vx * dt, y: ship.y + ship.vy * dt },
                    finish.p1,
                    finish.p2
                );
            };

            if (checkFinish(terrain.fFinishLine) || checkFinish(terrain.bFinishLine)) {
                gameState.status = GAME_STATUS.WIN;
                showGameOver('Success!', 'You have escaped to space!');
            }
        }

        function checkLineIntersection(p1, p2, p3, p4) {
            // Check if line segment p1-p2 intersects p3-p4
            const denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
            if (denominator === 0) return false;

            const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
            const ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;

            return (ua >= 0 && ua <= 1) && (ub >= 0 && ub <= 1);
        }

        function checkCollisions() {
            // Ship points (triangle)
            const nose = {
                x: ship.x + Math.cos(ship.angle) * 15,
                y: ship.y + Math.sin(ship.angle) * 15
            };
            const leftWing = {
                x: ship.x + Math.cos(ship.angle + 2.6) * 10,
                y: ship.y + Math.sin(ship.angle + 2.6) * 10
            };
            const rightWing = {
                x: ship.x + Math.cos(ship.angle - 2.6) * 10,
                y: ship.y + Math.sin(ship.angle - 2.6) * 10
            };

            const shipLines = [
                [nose, leftWing],
                [leftWing, rightWing],
                [rightWing, nose]
            ];

            // Determine relevant grid buckets
            // Ship radius is roughly 15, so check a bit wider
            const margin = 20;
            const startX = Math.floor((ship.x - margin) / terrain.cellSize);
            const endX = Math.floor((ship.x + margin) / terrain.cellSize);
            const startY = Math.floor((ship.y - margin) / terrain.cellSize);
            const endY = Math.floor((ship.y + margin) / terrain.cellSize);

            const checkedSegments = new Set();

            for (let x = startX; x <= endX; x++) {
                for (let y = startY; y <= endY; y++) {
                    const key = `${x},${y}`;
                    const bucket = terrain.grid2D[key];
                    if (!bucket) continue;

                    for (let segment of bucket) {
                        if (checkedSegments.has(segment)) continue;
                        checkedSegments.add(segment);

                        for (let sl of shipLines) {
                            if (checkLineIntersection(sl[0], sl[1], segment.p1, segment.p2)) {
                                if (segment.type === 'floor') {
                                    handleCollision(segment.p1, segment.p2);
                                } else {
                                    crash();
                                }
                                return;
                            }
                        }
                    }
                }
            }
        }

        function handleCollision(groundP1, groundP2) {
            // Check if it's a safe landing
            // 1. Is the surface flat? (y is same)
            const isFlat = Math.abs(groundP1.y - groundP2.y) < 1;

            // 2. Is speed low enough?
            const speed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);

            // 3. Is angle correct? (Upright)
            // Ship angle is -PI/2 when upright.
            // Normalize angle to -PI to PI
            let angle = ship.angle;
            while (angle <= -Math.PI) angle += Math.PI * 2;
            while (angle > Math.PI) angle -= Math.PI * 2;

            const isUpright = Math.abs(angle + Math.PI / 2) < SAFE_LANDING_ANGLE;

            if (isFlat && speed < SAFE_LANDING_SPEED && isUpright) {
                // Landed
                // Stop ship
                ship.landed = true;
                ship.vx = 0;
                ship.vy = 0;
                ship.angle = -Math.PI / 2; // Snap to upright
                // Align to surface
                // Ship height (wings) is 10px from center. 
                // We place it slightly higher (-11) to avoid immediate collision loop
                ship.y = groundP1.y - 11;
            } else {
                crash();
            }
        }

        function crash() {
            gameState.status = GAME_STATUS.CRASHED;
            createExplosion(ship.x, ship.y);
            showGameOver('Failure!', 'Your ship is no longer usable.');
        }

        function showGameOver(title, msg) {
            document.getElementById('msg-title').innerText = title;
            document.getElementById('msg-body').innerText = msg;
            document.getElementById('start-btn').innerText = 'Retry';
            document.getElementById('message-overlay').classList.add('visible');
        }

        function getTerrainAt(x, y) {
            let floorY = null;
            let ceilingY = null;

            const kx = Math.floor(x / terrain.cellSize);
            const ky = Math.floor(y / terrain.cellSize);

            // Check current and adjacent vertical buckets to handle boundary cases
            for (let offset = -1; offset <= 1; offset++) {
                const key = `${kx},${ky + offset}`;
                const bucket = terrain.grid2D[key];

                if (bucket) {
                    for (let seg of bucket) {
                        const minX = Math.min(seg.p1.x, seg.p2.x);
                        const maxX = Math.max(seg.p1.x, seg.p2.x);

                        // Ignore vertical segments for Y lookup
                        if (maxX - minX < 0.1) continue;

                        if (x >= minX && x <= maxX) {
                            const t = (x - seg.p1.x) / (seg.p2.x - seg.p1.x);
                            const val = seg.p1.y + t * (seg.p2.y - seg.p1.y);

                            if (seg.type === 'floor') {
                                floorY = val;
                            } else if (seg.type === 'ceiling') {
                                ceilingY = val;
                            }
                        }
                    }
                }
            }
            return { floorY, ceilingY };
        }

        function updateMines(dt) {
            const TRIGGER_DIST = 300;
            const DISABLE_DIST = 500;
            const ACCEL = 0.05;
            const MAX_SPEED = 2.0;

            // Mine-Mine Collision
            for (let i = 0; i < gameState.mines.length; i++) {
                for (let j = i + 1; j < gameState.mines.length; j++) {
                    const m1 = gameState.mines[i];
                    const m2 = gameState.mines[j];
                    if (!m1.active || !m2.active) continue;

                    const dx = m2.x - m1.x;
                    const dy = m2.y - m1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = m1.radius + m2.radius;

                    if (dist < minDist) {
                        // Check if either is active (seeking ship)
                        if (m1.state === 'active' || m2.state === 'active') {
                            // Explode both
                            m1.active = false;
                            m2.active = false;
                            createExplosion(m1.x, m1.y);
                            createExplosion(m2.x, m2.y);
                            continue;
                        }

                        // Resolve overlap
                        const overlap = minDist - dist;
                        const angle = Math.atan2(dy, dx);
                        const moveX = Math.cos(angle) * overlap * 0.5;
                        const moveY = Math.sin(angle) * overlap * 0.5;

                        m1.x -= moveX;
                        m1.y -= moveY;
                        m2.x += moveX;
                        m2.y += moveY;

                        // Bounce
                        const tx = Math.cos(angle);
                        const ty = Math.sin(angle);
                        const dp1 = m1.vx * tx + m1.vy * ty;
                        const dp2 = m2.vx * tx + m2.vy * ty;

                        const m1vx = tx * dp2;
                        const m1vy = ty * dp2;
                        const m2vx = tx * dp1;
                        const m2vy = ty * dp1;

                        m1.vx = m1vx + (m1.vx - tx * dp1);
                        m1.vy = m1vy + (m1.vy - ty * dp1);
                        m2.vx = m2vx + (m2.vx - tx * dp2);
                        m2.vy = m2vy + (m2.vy - ty * dp2);
                    }
                }
            }

            gameState.mines.forEach(mine => {
                if (!mine.active) return;

                // Distance to ship
                const dx = ship.x - mine.x;
                const dy = ship.y - mine.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // State Logic
                if (dist < TRIGGER_DIST) {
                    mine.state = 'active';
                } else if (dist > DISABLE_DIST) {
                    mine.state = 'idle';
                }

                // Movement Logic
                if (mine.state === 'active' && gameState.status !== GAME_STATUS.CRASHED) {
                    if (mine.type === 'seeker') {
                        // Magnetic attraction (Mine moves to Ship)
                        const angle = Math.atan2(dy, dx);
                        mine.vx += Math.cos(angle) * ACCEL * dt;
                        mine.vy += Math.sin(angle) * ACCEL * dt;

                        // Cap speed
                        const speed = Math.sqrt(mine.vx * mine.vx + mine.vy * mine.vy);
                        if (speed > MAX_SPEED) {
                            mine.vx = (mine.vx / speed) * MAX_SPEED;
                            mine.vy = (mine.vy / speed) * MAX_SPEED;
                        }
                    } else if (mine.type === 'gravity') {
                        // Gravity Well (Ship moves to Mine)
                        // Force = 2x GRAVITY. GRAVITY is 0.05, so 0.1.
                        // Direction is from Ship to Mine (so -dx, -dy)
                        const angle = Math.atan2(-dy, -dx);
                        const force = 0.1; // 2 * GRAVITY

                        // Apply to ship
                        ship.vx += Math.cos(angle) * force * dt;
                        ship.vy += Math.sin(angle) * force * dt;

                        // Mine stays still
                        mine.vx = 0;
                        mine.vy = 0;
                    }
                } else {
                    // Idle - Stationary
                    mine.vx = 0;
                    mine.vy = 0;
                }

                // Apply Velocity
                mine.x += mine.vx * dt;
                mine.y += mine.vy * dt;

                // Wall Collisions
                const { floorY, ceilingY } = getTerrainAt(mine.x, mine.y);
                if (floorY !== null && mine.y + mine.radius >= floorY) {
                    mine.y = floorY - mine.radius;
                    mine.vy *= -0.8; // Bounce
                }
                if (ceilingY !== null && mine.y - mine.radius <= ceilingY) {
                    mine.y = ceilingY + mine.radius;
                    mine.vy *= -0.8; // Bounce
                }

                // Ship Collision
                if (mine.state === 'active' && dist < mine.radius + ship.radius) {
                    mine.active = false; // Disable mine so it doesn't explode again
                    createExplosion(mine.x, mine.y);
                    crash();
                }
            });
        }

        function updateParticles(dt) {
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const p = gameState.particles[i];
                p.life -= (p.decay || 0.02) * dt; // Use custom decay or default
                p.x += p.vx * dt;
                p.y += p.vy * dt;

                if (p.type === 'smoke') {
                    p.size += 0.05 * dt;
                }

                // Particle Collision with Terrain
                const { floorY, ceilingY } = getTerrainAt(p.x, p.y);

                if (floorY !== null && p.y >= floorY) {
                    p.y = floorY - 1;
                    p.vy *= -0.2; // Reduced bounce
                    p.vx *= 0.8; // Friction
                }

                if (ceilingY !== null && p.y <= ceilingY) {
                    p.y = ceilingY + 1;
                    p.vy *= -0.2; // Reduced bounce
                    p.vx *= 0.8; // Friction
                }

                if (p.life <= 0) {
                    gameState.particles.splice(i, 1);
                }
            }
        }

        function draw() {
            // Clear background
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, width, height);

            // Camera transform
            ctx.save();

            // Smooth camera follow
            const z = gameState.camera.zoom;
            // Target coordinates are in world space (ship location), then translated to keep ship at screen center
            const targetX = -ship.x * z + width / 2;
            const targetY = -ship.y * z + height / 2;
            gameState.camera.x += (targetX - gameState.camera.x) * 0.1;
            gameState.camera.y += (targetY - gameState.camera.y) * 0.1;

            ctx.translate(gameState.camera.x, gameState.camera.y);
            ctx.scale(z, z);

            // Draw Terrain
            ctx.lineWidth = 2;

            // Visible range in world space
            const worldMinX = -gameState.camera.x / z;
            const worldMaxX = (-gameState.camera.x + width) / z;
            const worldMinY = -gameState.camera.y / z;
            const worldMaxY = (-gameState.camera.y + height) / z;

            const startCol = Math.floor(worldMinX / terrain.cellSize);
            const endCol = Math.floor(worldMaxX / terrain.cellSize);
            const startRow = Math.floor(worldMinY / terrain.cellSize);
            const endRow = Math.floor(worldMaxY / terrain.cellSize);

            for (let c = startCol - 1; c <= endCol + 1; c++) {
                for (let r = startRow - 1; r <= endRow + 1; r++) {
                    const key = `${c},${r}`;
                    const bucket = terrain.grid2D[key];
                    if (bucket) {
                        bucket.forEach(seg => {
                            ctx.strokeStyle = seg.color;
                            ctx.beginPath();
                            ctx.moveTo(seg.p1.x, seg.p1.y);
                            ctx.lineTo(seg.p2.x, seg.p2.y);
                            ctx.stroke();
                        });
                    }
                }
            }

            // Draw Finish Line
            const drawFinish = (finish) => {
                if (finish) {
                    ctx.strokeStyle = '#6366f1';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([10, 10]);
                    ctx.beginPath();
                    ctx.moveTo(finish.p1.x, finish.p1.y);
                    ctx.lineTo(finish.p2.x, finish.p2.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            };
            drawFinish(terrain.fFinishLine);
            drawFinish(terrain.bFinishLine);

            // Draw Particles
            gameState.particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.strokeStyle = p.color;

                // Draw as circle
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Draw Mines
            gameState.mines.forEach(mine => {
                if (!mine.active) return;
                // Only draw if visible
                if (mine.x < worldMinX - 100 || mine.x > worldMaxX + 100) return;

                ctx.save();
                ctx.translate(mine.x, mine.y);

                if (mine.state === 'active') {
                    if (mine.type === 'seeker') {
                        ctx.fillStyle = '#ef4444'; // Red
                        ctx.shadowColor = '#ef4444';
                    } else {
                        ctx.fillStyle = '#a855f7'; // Purple
                        ctx.shadowColor = '#a855f7';
                    }
                    ctx.shadowBlur = 15;
                } else {
                    ctx.fillStyle = '#475569'; // Slate
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                }

                ctx.beginPath();
                ctx.arc(0, 0, mine.radius, 0, Math.PI * 2);
                ctx.fill();

                // Inner detail
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                ctx.beginPath();
                ctx.arc(-3, -3, mine.radius * 0.4, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            });

            // Draw Ship
            if (gameState.status !== GAME_STATUS.CRASHED) {
                ctx.save();
                ctx.translate(ship.x, ship.y);
                ctx.rotate(ship.angle);


                // Draw Flame if thrusting
                if (keys.ArrowUp || keys.KeyW) { // Check input state for thrust
                    // We need to check if we are actually thrusting. 
                    // The updatePhysics function sets ship.landed = false if thrusting.
                    // But we don't have a direct 'isThrusting' flag on the ship.
                    // However, we can infer it from input keys or check if we want to add a flag.
                    // Let's use the input keys directly here for visual feedback.
                    const isThrusting = keys.ArrowUp || keys.KeyW; // Simplified check

                    if (isThrusting) {
                        ctx.fillStyle = Math.random() > 0.5 ? '#fbbf24' : '#ef4444'; // Flicker color
                        ctx.beginPath();
                        ctx.moveTo(-5, 0); // Engine center
                        const flameHeight = 15 + Math.random() * 10; // Varying height
                        ctx.lineTo(-flameHeight - 5, 0); // Tip of flame (pointing back)
                        // Actually, inverted triangle means base at ship, point away.
                        // Ship points right (0 deg) in local space? No, ship points along positive X in local space (nose at 15, 0).
                        // So back is negative X.
                        // We want a triangle at the back.
                        // Base: (-5, -3) to (-5, 3)
                        // Tip: (-5 - flameHeight, 0)

                        ctx.beginPath();
                        ctx.moveTo(-5, -3);
                        ctx.lineTo(-5, 3);
                        ctx.lineTo(-5 - flameHeight, 0);
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                ctx.fillStyle = ship.color;

                ctx.beginPath();
                // Triangle ship
                ctx.moveTo(15, 0); // Nose
                ctx.lineTo(-10, 10); // Left wing
                ctx.lineTo(-5, 0); // Engine indent
                ctx.lineTo(-10, -10); // Right wing
                ctx.closePath();
                ctx.fill();

                // Add stroke
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#ffffff';
                ctx.stroke();


                ctx.restore();
            }

            ctx.restore();

            // Update UI
            const distPixels = Math.abs(ship.x);
            const distMeters = Math.round(distPixels * (3 / 25)); // Ship length ~25px = 3m
            document.getElementById('distance-display').innerText = `DIST: ${distMeters.toLocaleString()} m`;
        }

        function loop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTimeMillis = timestamp - lastTime;
            lastTime = timestamp;

            // Target 60 FPS (16.67ms per frame)
            const dt = deltaTimeMillis / (1000 / 60);
            if (gameState.status === GAME_STATUS.PLAYING) {
                updatePhysics(dt);
                updateMines(dt);
            }
            updateParticles(dt);

            draw();

            animationId = requestAnimationFrame(loop);
        }

        // Initial setup
        resize();
        generateLevel();
        // Start loop immediately for smoother transitions/previews
        lastTime = performance.now();
        animationId = requestAnimationFrame(loop);

    </script>
</body>

</html>